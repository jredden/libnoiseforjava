package example;

import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.List;

import libnoiseforjava.NoiseGen.NoiseQuality;
import libnoiseforjava.domain.Builder;
import libnoiseforjava.domain.GradientPointParameter;
import libnoiseforjava.domain.RenderImageParameter;
import libnoiseforjava.domain.RenderImageSphereParameter;
import libnoiseforjava.module.Blend;
import libnoiseforjava.module.Cached;
import libnoiseforjava.module.Clamp;
import libnoiseforjava.module.Const;
import libnoiseforjava.module.Curve;
import libnoiseforjava.module.Min;
import libnoiseforjava.module.Perlin;
import libnoiseforjava.module.RidgedMulti;
import libnoiseforjava.module.ScaleBias;
import libnoiseforjava.module.Select;
import libnoiseforjava.module.Terrace;
import libnoiseforjava.module.Turbulence;
import libnoiseforjava.persistence.Output;
import libnoiseforjava.util.ColorCafe;
import libnoiseforjava.util.ImageCafe;
import libnoiseforjava.util.NoiseMap;
import libnoiseforjava.util.NoiseMapBuilder;
import libnoiseforjava.util.NoiseMapBuilderSphere;
import libnoiseforjava.util.RendererImage;

import com.zenred.util.GenRandomRolls;

import org.junit.Test;

public class ComplexPlanetTest {
	/**
	 * these values should either be generated by an AI engine and (possibly
	 * persisted in the store)
	 */

	// //////////////////////////////////////////////////////////////////////////
	// Constants
	//
	// Modify these constants to change the terrain of the planet and to change
	// the boundaries and size of the elevation grid.
	//
	// Note: "Planetary elevation units" range from -1.0 (for the lowest
	// underwater trenches) to +1.0 (for the highest mountain peaks.)
	//

	// Planet seed. Change this to generate a different planet
	// A different planet each test (almost always)
	private static Integer CUR_SEED = GenRandomRolls.Instance().getD1000();
	// Frequency of the planet's continents. Higher frequency produces smaller,
	// more numerous continents. This value is measured in radians.
	private static Double CONTINENT_FREQUENCY = 1.0;
	// The persistence value controls the roughness of the Perlin noise,
	// normally between 0.0 and 1.0
	private static Double BASE_CONTINENT_DEF_PERSISTENCE_0 = 0.5;
	private static Double BASE_CONTINENT_DEF_PERSISTENCE_1 = 0.5;
	// Lacunarity. from Latin meaning gap, or fill space
	// Lacunarity of the planet's continents. Changing this value produces
	// slightly different continents. For the best results, this value should
	// be random, but close to 2.0.
	private static Double CONTINENT_LACUNARITY = 2.208984375;
	// Octave count determines the amount of Perlin noise, the higher the count,
	// the more detail
	private static Integer BASE_CONTINENT_DEF_OCTAVE_COUNT_PE0 = 14;
	private static Integer BASE_CONTINENT_DEF_OCTAVE_COUNT_PE1 = 11;
	// Specifies the planet's sea level. This value must be between -1.0
	// (minimum planet elevation) and +1.0 (maximum planet elevation.)
	private static Double SEA_LEVEL = 0.0;
	// / Sets the bias to apply to the scaled output value from the source
	// / module.
	private static Double DEEP_SEA_LEVEL = -256.0;
	private static Double BASE_CONTINENT_DEF_BIAS = 0.625;
	// / Sets the scaling factor to apply to the output value from the
	// / source module.
	private static Double BASE_CONTINENT_DEF_SCALE = 0.375;
	// noise clamping bounds
	private static Double BASE_CONTINENT_DEF_CLAMP_LOWER_BOUND = -1.0;
	private static Double BASE_CONTINENT_DEF_CLAMP_UPPER_BOUND = 1.0;
	// Minimum elevation on the planet, in meters. This value is approximate.
	private static Double MIN_ELEV = -8192.0;
	// Maximum elevation on the planet, in meters. This value is approximate.
	private static Double MAX_ELEV = 8192.0;
	// sea level calculation parameters
	private static Double PARAMETER0 = 1.0;
	private static Double PARAMETER1 = 2.0;
	// Calculate the sea level, in meters
	private static Double seaLevelInMeters = (((SEA_LEVEL + PARAMETER0) / PARAMETER1) * (MAX_ELEV - MIN_ELEV))
			+ MIN_ELEV;
	// Southernmost coordinate of elevation grid.
	private static Double SOUTH_COORD = -90.0;
	// Northernmost coordinate of elevation grid.
	private static Double NORTH_COORD = 90.0;
	// Westernmost coordinate of elevation grid.
	private static Double WEST_COORD = -180.0;
	// Easternmost coordinate of elevation grid.
	private static Double EAST_COORD = 180.0;
	// Width of elevation grid, in points
	private static Integer GRID_WIDTH = 4096;
	// Height of elevation grid, in points
	private static Integer GRID_HEIGHT = 2048;

	private static Double PLANET_CIRCUMFERENCE = 44236800.0;
	private static Double METERS_PER_DEGREE = PLANET_CIRCUMFERENCE / 360.0;

	// Offset to apply to the terrain type definition. Low values (< 1.0) cause
	// the rough areas to appear only at high elevations. High values (> 2.0)
	// cause the rough areas to appear at any elevation. The percentage of
	// rough areas on the planet are independent of this value.
	private static Double TERRAIN_OFFSET = 1.0;

	//

	// create a spherical-noise-map builder
	private static NoiseMapBuilderSphere planet = new NoiseMapBuilderSphere();
	private static NoiseMap elevGrid = new NoiseMap(GRID_HEIGHT, GRID_WIDTH);
	static {
		planet.setBounds(SOUTH_COORD, NORTH_COORD, WEST_COORD, EAST_COORD);
		planet.setDestSize(100, 100);

	}

	static List<GradientPointParameter> gradientPointList = new ArrayList<GradientPointParameter>();
	static {
		GradientPointParameter gradientPointParameter = new GradientPointParameter(
				-16384.0 + seaLevelInMeters, new ColorCafe(3, 29, 63, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(DEEP_SEA_LEVEL
				+ seaLevelInMeters, new ColorCafe(3, 29, 63, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(-1.0
				+ seaLevelInMeters, new ColorCafe(7, 106, 127, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(
				0.0 + seaLevelInMeters, new ColorCafe(62, 86, 30, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(
				1024.0 + seaLevelInMeters, new ColorCafe(84, 96, 50, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(
				2048.0 + seaLevelInMeters, new ColorCafe(130, 127, 97, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(
				3072.0 + seaLevelInMeters, new ColorCafe(184, 163, 141, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(
				4096.0 + seaLevelInMeters, new ColorCafe(255, 255, 255, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(
				6144.0 + seaLevelInMeters, new ColorCafe(128, 255, 255, 255));
		gradientPointList.add(gradientPointParameter);
		gradientPointParameter = new GradientPointParameter(
				16384.0 + seaLevelInMeters, new ColorCafe(0, 0, 255, 255));
		gradientPointList.add(gradientPointParameter);

	}

	static Double lightContrast = new Double(3.0);
	static Double lightBrightness = new Double(2.0);
	static Double lightElevation = new Double(45.0);
	static Double lightAzumith = new Double(135.0);

	static Double degExtent = EAST_COORD - WEST_COORD;
	static Double gridExtent = new Double(GRID_WIDTH);
	// double resInMeters = (degExtent / gridExtent) * metersPerDegree;
	static Double resInMeters = (degExtent / gridExtent) * METERS_PER_DEGREE;
	static Double INVERSE_RES_IN_METERS = 1.0 / resInMeters;

	// Specifies the level on the planet in which continental shelves appear.
	// This value must be between -1.0 (minimum planet elevation) and +1.0
	// (maximum planet elevation), and must be less than SEA_LEVEL.
	static Double SHELF_LEVEL = -0.375;

	// Lacunarity of the planet's mountains. Changing this value produces
	// slightly different mountains. For the best results, this value should
	// be random, but close to 2.0.
	static Double MOUNTAIN_LACUNARITY = 2.142578125;
	
	  // Specifies the "twistiness" of the mountains.
	 static Double MOUNTAINS_TWIST = 1.0;

	// 1: [Continent module]: This Perlin-noise module generates the continents.
	// This noise module has a high number of octaves so that detail is
	// visible at high zoom levels.

	static private Perlin baseContinentDef_pe0 = new Perlin();
	static {
		baseContinentDef_pe0.setSeed(CUR_SEED);
		baseContinentDef_pe0.setFrequency(CONTINENT_FREQUENCY);
		baseContinentDef_pe0.setPersistence(BASE_CONTINENT_DEF_PERSISTENCE_0);
		baseContinentDef_pe0.setLacunarity(CONTINENT_LACUNARITY);
		baseContinentDef_pe0
				.setOctaveCount(BASE_CONTINENT_DEF_OCTAVE_COUNT_PE0);
		baseContinentDef_pe0.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 2: [Continent-with-ranges module]: Next, a curve module modifies the
	// output value from the continent module so that very high values appear
	// near sea level. This defines the positions of the mountain ranges.
	static private Curve baseContinentDef_cu = new Curve(baseContinentDef_pe0);
	static {
		baseContinentDef_cu.addControlPoint(-2.0000 + SEA_LEVEL, -1.625
				+ SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(-1.0000 + SEA_LEVEL, -1.375
				+ SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.0000 + SEA_LEVEL, -0.375
				+ SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.0625 + SEA_LEVEL,
				0.125 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.1250 + SEA_LEVEL,
				0.250 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.2500 + SEA_LEVEL,
				1.000 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.5000 + SEA_LEVEL,
				0.250 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(0.7500 + SEA_LEVEL,
				0.250 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(1.0000 + SEA_LEVEL,
				0.500 + SEA_LEVEL);
		baseContinentDef_cu.addControlPoint(2.0000 + SEA_LEVEL,
				0.500 + SEA_LEVEL);

	}
	// 3: [Carver module]: This higher-frequency Perlin-noise module will be
	// used by subsequent noise modules to carve out chunks from the mountain
	// ranges within the continent-with-ranges module so that the mountain
	// ranges will not be complely impassible.

	static private Perlin baseContinentDef_pe1 = new Perlin();
	static {
		baseContinentDef_pe1.setSeed(CUR_SEED + 1);
		baseContinentDef_pe1.setFrequency(CONTINENT_FREQUENCY);
		baseContinentDef_pe1.setPersistence(BASE_CONTINENT_DEF_PERSISTENCE_1);
		baseContinentDef_pe1.setLacunarity(CONTINENT_LACUNARITY);
		baseContinentDef_pe1
				.setOctaveCount(BASE_CONTINENT_DEF_OCTAVE_COUNT_PE1);
		baseContinentDef_pe1.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 4: [Scaled-carver module]: This scale/bias module scales the output
	// value from the carver module such that it is usually near 1.0. This
	// is required for step 5.

	static private ScaleBias baseContinentDef_sb = new ScaleBias(
			baseContinentDef_pe1);
	static {
		baseContinentDef_sb.setScale(BASE_CONTINENT_DEF_SCALE);
		baseContinentDef_sb.setBias(BASE_CONTINENT_DEF_BIAS);
	}

	// 5: [Carved-continent module]: This minimum-value module carves out chunks
	// from the continent-with-ranges module. It does this by ensuring that
	// only the minimum of the output values from the scaled-carver module
	// and the continent-with-ranges module contributes to the output value
	// of this subgroup. Most of the time, the minimum-value module will
	// select the output value from the continents-with-ranges module since
	// the output value from the scaled-carver module is usually near 1.0.
	// Occasionally, the output value from the scaled-carver module will be
	// less than the output value from the continent-with-ranges module, so
	// in this case, the output value from the scaled-carver module is
	// selected.
	static private Min baseContinentDef_mi = new Min(baseContinentDef_sb,
			baseContinentDef_cu);

	// 6: [Clamped-continent module]: Finally, a clamp module modifies the
	// carved-continent module to ensure that the output value of this
	// subgroup is between -1.0 and 1.0.

	static private Clamp baseContinentDef_cl = new Clamp(baseContinentDef_mi);
	static {
		baseContinentDef_cl.setBounds(BASE_CONTINENT_DEF_CLAMP_LOWER_BOUND,
				BASE_CONTINENT_DEF_CLAMP_UPPER_BOUND);
	}

	static private Cached baseContinentDef = new Cached(baseContinentDef_cl);

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: continent definition (5 noise modules)
	//
	// This subgroup warps the output value from the the base-continent-
	// definition subgroup, producing more realistic terrain.
	//
	// Warping the base continent definition produces lumpier terrain with
	// cliffs and rifts.
	//
	// -1.0 represents the lowest elevations and +1.0 represents the highest
	// elevations.
	//

	// 1: [Coarse-turbulence module]: This turbulence module warps the output
	// value from the base-continent-definition subgroup, adding some coarse
	// detail to it.
	static private Double TU0_FREQUENCY = 15.25;
	// / The frequency of the turbulence determines how rapidly the
	// / displacement amount changes.
	static private Double TU0_POWER_SCALAR = 113.75;
	// / The power of the turbulence determines the scaling factor that is
	// / applied to the displacement amount.
	static private Integer TU0_ROUGHNESS = 13;
	// / The roughness of the turbulence determines the roughness of the
	// / changes to the displacement amount. Low values smoothly change
	// / the displacement amount. High values roughly change the
	// / displacement amount, which produces more "kinky" changes.
	// /
	// / Internally, there are three Perlin noise modules
	// / that displace the input value; one for the @a x, one for the @a y,
	// / and one for the @a z coordinate. The roughness value is equal to
	// / the number of octaves used by the noise::module::Perlin noise
	// / modules.

	static private Turbulence continentDef_tu0 = new Turbulence(
			baseContinentDef);
	static {
		continentDef_tu0.setSeed(CUR_SEED + 10);
		continentDef_tu0.setFrequency(TU0_FREQUENCY * CONTINENT_FREQUENCY);
		continentDef_tu0.setPower(CONTINENT_FREQUENCY / TU0_POWER_SCALAR);
		continentDef_tu0.setRoughness(TU0_ROUGHNESS);
	}

	// 2: [Intermediate-turbulence module]: This turbulence module warps the
	// output value from the coarse-turbulence module. This turbulence has
	// a higher frequency, but lower power, than the coarse-turbulence
	// module, adding some intermediate detail to it.

	static private Double TU1_FREQUENCY = 47.25;
	static private Double TU1_POWER_SCALAR = 433.75;
	static private Integer TU1_ROUGHNESS = 12;

	static private Turbulence continentDef_tu1 = new Turbulence(
			continentDef_tu0);
	static {
		continentDef_tu1.setSeed(CUR_SEED + 11);
		continentDef_tu1.setFrequency(TU1_FREQUENCY * CONTINENT_FREQUENCY);
		continentDef_tu1.setPower(CONTINENT_FREQUENCY / TU1_POWER_SCALAR);
		continentDef_tu1.setRoughness(TU1_ROUGHNESS);
	}

	// 3: [Warped-base-continent-definition module]: This turbulence module
	// warps the output value from the intermediate-turbulence module. This
	// turbulence has a higher frequency, but lower power, than the
	// intermediate-turbulence module, adding some fine detail to it.

	static private Double TU2_FREQUENCY = 95.25;
	static private Double TU2_POWER_SCALAR = 1019.75;
	static private Integer TU2_ROUGHNESS = 11;

	static private Turbulence continentDef_tu2 = new Turbulence(
			continentDef_tu1);
	static {
		continentDef_tu2.setSeed(CUR_SEED + 12);
		continentDef_tu2.setFrequency(TU2_FREQUENCY * CONTINENT_FREQUENCY);
		continentDef_tu2.setPower(CONTINENT_FREQUENCY / TU2_POWER_SCALAR);
		continentDef_tu2.setRoughness(TU2_ROUGHNESS);

	}
	// 4: [Select-turbulence module]: At this stage, the turbulence is applied
	// to the entire base-continent-definition subgroup, producing some very
	// rugged, unrealistic coastlines. This selector module selects the
	// output values from the (unwarped) base-continent-definition subgroup
	// and the warped-base-continent-definition module, based on the output
	// value from the (unwarped) base-continent-definition subgroup. The
	// selection boundary is near sea level and has a relatively smooth
	// transition. In effect, only the higher areas of the base-continent-
	// definition subgroup become warped; the underwater and coastal areas
	// remain unaffected.

	// / The control module (baseContinentDef) determines the output value to
	// select. If the
	// / output value from the control module is within a range of values
	// / known as the <i>selection range</i>, the getValue() method outputs
	// / the value from the source module with an index value of 1.
	// / Otherwise, this method outputs the value from the source module
	// / with an index value of 0.
	// /
	// / This method assigns the control module an index value of 2.
	// / Passing the control module to this method produces the same
	// / results as passing the control module to the setSourceModule()
	// / method while assigning that noise module an index value of 2.
	// /
	// / This control module must exist throughout the lifetime of this
	// / noise module unless another control module replaces that control
	// / module.

	private static Double CONTINENT_DEF_SE_LOWER_BOUNDS = SEA_LEVEL - 0.0375;
	private static Double CONTINENT_DEF_SE_UPPER_BOUNDS = SEA_LEVEL + 1000.0375;
	private static Double CONTINENT_DEF_SE_EDGE_FALLOFF = 0.0625;
	// / By default, there is an abrupt transition between the values from
	// / the two source modules at the boundaries of the selection range.
	// /
	// / For example, if the selection range is 0.5 to 0.8, and the edge
	// / falloff value is 0.1, then the getValue() method outputs:
	// / - the output value from the source module with an index value of 0
	// / if the output value from the control module is less than 0.4
	// / ( = 0.5 - 0.1).
	// / - a linear blend between the two output values from the two source
	// / modules if the output value from the control module is between
	// / 0.4 ( = 0.5 - 0.1) and 0.6 ( = 0.5 + 0.1).
	// / - the output value from the source module with an index value of 1
	// / if the output value from the control module is between 0.6
	// / ( = 0.5 + 0.1) and 0.7 ( = 0.8 - 0.1).
	// / - a linear blend between the output values from the two source
	// / modules if the output value from the control module is between
	// / 0.7 ( = 0.8 - 0.1 ) and 0.9 ( = 0.8 + 0.1).
	// / - the output value from the source module with an index value of 0
	// / if the output value from the control module is greater than 0.9
	// / ( = 0.8 + 0.1).

	static private Select continentDef_se = new Select(baseContinentDef,
			continentDef_tu2, baseContinentDef);
	static {
		continentDef_se.setBounds(CONTINENT_DEF_SE_LOWER_BOUNDS,
				CONTINENT_DEF_SE_UPPER_BOUNDS);
		continentDef_se.setEdgeFalloff(CONTINENT_DEF_SE_EDGE_FALLOFF);
	}

	static private Cached continentDef = new Cached(continentDef_se);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: terrain type definition
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: terrain type definition (3 noise modules)
	//
	// This subgroup defines the positions of the terrain types on the planet.
	//
	// Terrain types include, in order of increasing roughness, plains, hills,
	// and mountains.
	//
	// This subgroup's output value is based on the output value from the
	// continent-definition group. Rougher terrain mainly appears at higher
	// elevations.
	//
	// -1.0 represents the smoothest terrain types (plains and underwater) and
	// +1.0 represents the roughest terrain types (mountains).
	//

	// 1: [Warped-continent module]: This turbulence module slightly warps the
	// output value from the continent-definition group. This prevents the
	// rougher terrain from appearing exclusively at higher elevations.
	// Rough areas may now appear in the the ocean, creating rocky islands
	// and fjords.

	static private Double TERRAIN_TYPE_TU_FREQUENCY = 18.125;
	static private Double TERRAIN_TYPE_TU_POWER = 20.59375;
	static private Integer TERRAIN_TYPE_TU_ROUGHNESS = 3;
	static private Turbulence terrainTypeDef_tu = new Turbulence(continentDef);
	static {
		terrainTypeDef_tu.setSeed(CUR_SEED + 20);
		terrainTypeDef_tu.setFrequency(CONTINENT_FREQUENCY
				* TERRAIN_TYPE_TU_FREQUENCY);
		terrainTypeDef_tu.setPower(CONTINENT_FREQUENCY / TERRAIN_TYPE_TU_POWER
				* TERRAIN_OFFSET);
		terrainTypeDef_tu.setRoughness(TERRAIN_TYPE_TU_ROUGHNESS);
	}

	// 2: [Roughness-probability-shift module]: This terracing module sharpens
	// the edges of the warped-continent module near sea level and lowers
	// the slope towards the higher-elevation areas. This shrinks the areas
	// in which the rough terrain appears, increasing the "rarity" of rough
	// terrain.
	static private Double TERRAIN_TYPE_DEF_LOW_CONTROL_POINT = -1.00;
	static private Double TERRAIN_TYPE_DEF_MID_CONTROL_POINT_SCALAR = 2.00;
	static private Double TERRAIN_TYPE_DEF_HIGH_CONTROL_POINT = 1.00;

	static private Terrace terrainTypeDef_te = new Terrace(terrainTypeDef_tu);
	static {
		terrainTypeDef_te.addControlPoint(TERRAIN_TYPE_DEF_LOW_CONTROL_POINT);
		terrainTypeDef_te.addControlPoint(SHELF_LEVEL + SEA_LEVEL
				/ TERRAIN_TYPE_DEF_MID_CONTROL_POINT_SCALAR);
		terrainTypeDef_te.addControlPoint(TERRAIN_TYPE_DEF_HIGH_CONTROL_POINT);

	}

	static private Cached terrainTypeDef = new Cached(terrainTypeDef_te);

	// //////////////////////////////////////////////////////////////////////////
	// Module group: mountainous terrain
	// //////////////////////////////////////////////////////////////////////////

	// //////////////////////////////////////////////////////////////////////////
	// Module subgroup: mountain base definition (9 noise modules)
	//
	// This subgroup generates the base-mountain elevations. Other subgroups
	// will add the ridges and low areas to the base elevations.
	//
	// -1.0 represents low mountainous terrain and +1.0 represents high
	// mountainous terrain.
	//

	// 1: [Mountain-ridge module]: This ridged-multifractal-noise module
	// generates the mountain ridges.
	static private Double MOUNTAIN_BASE_DEF_RM0_FREQUENCY = 1723.0;
	static private Integer MOUNTAIN_BASE_DEF_RM0_OCTAVE_COUNT = 4;
	static private RidgedMulti mountainBaseDef_rm0 = new RidgedMulti();
	static {
		mountainBaseDef_rm0.setSeed(CUR_SEED + 30);
		mountainBaseDef_rm0.setFrequency(MOUNTAIN_BASE_DEF_RM0_FREQUENCY);
		mountainBaseDef_rm0.setLacunarity(MOUNTAIN_LACUNARITY);
		mountainBaseDef_rm0.setOctaveCount(MOUNTAIN_BASE_DEF_RM0_OCTAVE_COUNT);
		mountainBaseDef_rm0.setNoiseQuality(NoiseQuality.QUALITY_STD);
	}

	// 2: [Scaled-mountain-ridge module]: Next, a scale/bias module scales the
	// output value from the mountain-ridge module so that its ridges are not
	// too high. The reason for this is that another subgroup adds actual
	// mountainous terrain to these ridges.
	static private Double MOUNTAIN_BASE_DEF_SB0_SCALE = 0.5;
	static private Double MOUNTAIN_BASE_DEF_SB0_BIAS = 0.375;

	static private ScaleBias mountainBaseDef_sb0 = new ScaleBias(
			mountainBaseDef_rm0);
	static {
		mountainBaseDef_sb0.setScale(MOUNTAIN_BASE_DEF_SB0_SCALE);
		mountainBaseDef_sb0.setBias(MOUNTAIN_BASE_DEF_SB0_BIAS);
	}

	// 3: [River-valley module]: This ridged-multifractal-noise module generates
	// the river valleys. It has a much lower frequency than the mountain-
	// ridge module so that more mountain ridges will appear outside of the
	// valleys. Note that this noise module generates ridged-multifractal
	// noise using only one octave; this information will be important in the
	// next step.
	static private Double MOUNTAIN_BASE_DEF_RM1_FREQUENCY = 367.0;
	static private Integer MOUNTAIN_BASE_DEF_RM1_OCTAVE_COUNT = 1;

	static private RidgedMulti mountainBaseDef_rm1 = new RidgedMulti();
	static {
		mountainBaseDef_rm1.setSeed(CUR_SEED + 31);
		mountainBaseDef_rm1.setFrequency(MOUNTAIN_BASE_DEF_RM1_FREQUENCY);
		mountainBaseDef_rm1.setLacunarity(MOUNTAIN_LACUNARITY);
		mountainBaseDef_rm1.setOctaveCount(MOUNTAIN_BASE_DEF_RM1_OCTAVE_COUNT);
		mountainBaseDef_rm1.setNoiseQuality(NoiseQuality.QUALITY_BEST);
	}

	  // 4: [Scaled-river-valley module]: Next, a scale/bias module applies a
	  //    scaling factor of -2.0 to the output value from the river-valley
	  //    module.  This stretches the possible elevation values because one-
	  //    octave ridged-multifractal noise has a lower range of output values
	  //    than multiple-octave ridged-multifractal noise.  The negative scaling
	  //    factor inverts the range of the output value, turning the ridges from
	  //    the river-valley module into valleys.
	static private Double MOUNTAIN_BASE_DEF_SB1_SCALE = -2.0;
	static private Double MOUNTAIN_BASE_DEF_SB1_BIAS = -0.5;

	static private ScaleBias mountainBaseDef_sb1 = new ScaleBias(
			mountainBaseDef_rm1);
	static {
		mountainBaseDef_sb1.setScale(MOUNTAIN_BASE_DEF_SB1_SCALE);
		mountainBaseDef_sb1.setBias(MOUNTAIN_BASE_DEF_SB1_BIAS);
	}
	
	static public Const mountainBaseDef_co = new Const();
	static {
		mountainBaseDef_co.setConstValue(-1.0);  // wimpy ... 
	}
	  // 6: [Mountains-and-valleys module]: This blender module merges the
	  //    scaled-mountain-ridge module and the scaled-river-valley module
	  //    together.  It causes the low-lying areas of the terrain to become
	  //    smooth, and causes the high-lying areas of the terrain to contain
	  //    ridges.  To do this, it uses the scaled-river-valley module as the
	  //    control module, causing the low-flat module to appear in the lower
	  //    areas and causing the scaled-mountain-ridge module to appear in the
	  //    higher areas.

	static private Blend mountainBaseDef_bl = new Blend(mountainBaseDef_co, mountainBaseDef_sb0, mountainBaseDef_sb1);
	
	  // 7: [Coarse-turbulence module]: This turbulence module warps the output
	  //    value from the mountain-and-valleys module, adding some coarse detail
	  //    to it.
	static private Double MOUNTAIN_BASE_DEF_TU1_FREQUENCY = 21221.0;
	static private Double MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR0 = 1.0;
	static private Double MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR1 = 120157.0 * MOUNTAINS_TWIST;
	static private Integer MOUNTAIN_BASE_DEF_TU1_ROUGHNESS = 6;
	static private Turbulence  mountainBaseDef_tu1 = new Turbulence(mountainBaseDef_bl);
	static{
		mountainBaseDef_tu1.setSeed(CUR_SEED+33);
		mountainBaseDef_tu1.setFrequency(MOUNTAIN_BASE_DEF_TU1_FREQUENCY);
		mountainBaseDef_tu1.setPower(MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR0/MOUNTAIN_BASE_DEF_TU1_POWER_SCALAR1);
		mountainBaseDef_tu1.setRoughness(MOUNTAIN_BASE_DEF_TU1_ROUGHNESS);
	}
	
	@Test
	public void test() {
		// Build the elevation grid with the output values from the final-planet
		// group.
		planet.setSourceModule(baseContinentDef);
		planet.setDestNoiseMap(elevGrid);
		planet.build();
		RendererImage surfaceRenderer = new RendererImage();
		ImageCafe destImage = new ImageCafe(elevGrid.getWidth(),
				elevGrid.getHeight());
		surfaceRenderer.setDestImage(destImage);
		surfaceRenderer.setSourceNoiseMap(elevGrid);
		surfaceRenderer.clearGradient();
		for (GradientPointParameter gradientPointParameter : gradientPointList) {
			surfaceRenderer.addGradientPoint(
					gradientPointParameter.getGradientPosition(),
					gradientPointParameter.getColorCafe());
		}
		surfaceRenderer.enableLight(Boolean.TRUE);
		surfaceRenderer.setLightContrast(lightContrast);
		surfaceRenderer.setLightIntensity(lightBrightness);
		surfaceRenderer.setLightElev(lightElevation);
		surfaceRenderer.setLightAzimuth(lightAzumith);
		surfaceRenderer.render();
		String uri = "images/" + Math.random() + "complextPlanet0_test.png";
		Output.writer(destImage, uri);

	}

	@Test
	public void test0() {
		// Build the elevation grid with the output values from the final-planet
		// group.
		planet.setSourceModule(baseContinentDef);
		planet.setDestNoiseMap(elevGrid);
		planet.build();
		RenderImageParameter renderImageParameter = new RenderImageParameter(
				gradientPointList, elevGrid, Boolean.TRUE, lightContrast,
				lightBrightness);
		ImageCafe imageCafe = Builder.buildRendererImage(renderImageParameter);
		String uri = "images/" + Math.random() + "complextPlanet1_test.png";
		Output.writer(imageCafe, uri);

	}

	@Test
	public void test1() {
		// Build the elevation grid with the output values from the final-planet
		// group.
		planet.setSourceModule(continentDef);
		planet.setDestNoiseMap(elevGrid);
		planet.build();
		RenderImageParameter renderImageParameter = new RenderImageParameter(
				gradientPointList, elevGrid, Boolean.TRUE, lightContrast,
				lightBrightness);
		ImageCafe imageCafe = Builder.buildRendererImage(renderImageParameter);
		String uri = "images/" + Math.random() + "complextPlanet2_test.png";
		Output.writer(imageCafe, uri);

	}

	@Test
	public void test2() {
		// Build the elevation grid with the output values from the final-planet
		// group.
		planet.setSourceModule(terrainTypeDef);
		planet.setDestNoiseMap(elevGrid);
		planet.build();
		RenderImageParameter renderImageParameter = new RenderImageParameter(
				gradientPointList, elevGrid, Boolean.TRUE, lightContrast,
				lightBrightness);
		ImageCafe imageCafe = Builder.buildRendererImage(renderImageParameter);
		String uri = "images/" + Math.random() + "complextPlanet3_test.png";
		Output.writer(imageCafe, uri);

	}
}
